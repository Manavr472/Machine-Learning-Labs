# -*- coding: utf-8 -*-
"""ML_Exp5_A33_(K mean Cluster)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RMjVWE3w1zi2GzARTnU9_c8HCmz-UnWi
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
from sklearn.feature_selection import SelectKBest, chi2
from sklearn.model_selection import train_test_split, KFold, cross_val_score
from sklearn.linear_model import LogisticRegression
from sklearn.preprocessing import MinMaxScaler, LabelEncoder
from sklearn.metrics import accuracy_score
import numpy as np

# Load the dataset
df = pd.read_csv('/content/drive/MyDrive/Machine learning Lab/drugbank_clean_no_outliers_IQR.csv')

# Label encoding function
def label_encode(df):
    label_encoder = LabelEncoder()
    for column in df.columns:
        if df[column].dtype == 'bool':
            df[column] = df[column].astype(int)
        elif df[column].dtype == 'object':
            df[column] = label_encoder.fit_transform(df[column])
    return df

df = label_encode(df)

# Handle missing values
df.fillna(df.median(), inplace=True)

# Remove zero variance features
non_zero_variance_features = df.loc[:, df.var() > 0]

X = df.drop(columns=['targets'])

X.info()

!pip install kneed

#Display optimal no. of clusters using Elbow Method
#Libraries for Kmeans
import matplotlib.pyplot as plt
from kneed import KneeLocator
from sklearn.cluster import KMeans
import numpy as np
# Elbow Method to calculate inertia for different values of k
def elbow_method(X):
    inertia = []
    k_range = range(1, 7)  # You can adjust the range based on your data
    for k in k_range:
        kmeans = KMeans(n_clusters=k, random_state=42)
        kmeans.fit(X)
        inertia.append(kmeans.inertia_)  # Inertia is the sum of squared distances
    return inertia

# Find optimal number of clusters using the Elbow Method
def find_optimal_k(inertia_values):
    k_range = range(1, len(inertia_values) + 1)

    # Use KneeLocator to find the elbow
    kn = KneeLocator(k_range, inertia_values, curve='convex', direction='decreasing')
    optimal_k = kn.knee

    # Plot the inertia vs number of clusters
    plt.figure(figsize=(8, 6))
    plt.plot(k_range, inertia_values, 'bo-', label='Inertia')
    if optimal_k:
        plt.axvline(x=optimal_k, color='r', linestyle='--', label=f'Optimal k = {optimal_k}')
    plt.xlabel('Number of clusters (k)')
    plt.ylabel('Inertia')
    plt.title('Elbow Method to Find Optimal k')
    plt.legend()
    plt.grid(True)
    plt.show()

    if optimal_k:
        print(f"The optimal number of clusters is: {optimal_k}")
    else:
        print("No optimal k found. Check the plot for the elbow manually.")

    return optimal_k

# Example usage
inertia_values = elbow_method(X)
optimal_k = find_optimal_k(inertia_values)

# Import necessary libraries
import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans

# Select the columns for clustering (replace with relevant columns from your dataset)
data_for_clustering = df[['name', 'drug-interactions', 'groups']]

# Handle missing values (you can choose to drop or impute missing values)
data_for_clustering = data_for_clustering[~np.isnan(data_for_clustering).any(axis=1)]  # Dropping rows with NaN

# Standardize the data
scaler = StandardScaler()
data_scaled = scaler.fit_transform(data_for_clustering)

# Perform KMeans clustering with the desired number of clusters
optimal_k = 3  # Replace this with your chosen number of clusters
kmeans = KMeans(n_clusters=optimal_k)
clusters = kmeans.fit_predict(data_scaled)

# Plot the clusters using the first two features (for visualization)
plt.figure(figsize=(8, 6))
plt.scatter(data_scaled[:, 0], data_scaled[:, 1], c=clusters, cmap='viridis', s=50)
plt.scatter(kmeans.cluster_centers_[:, 0], kmeans.cluster_centers_[:, 1], c='red', s=200, marker='X', label='Centroids')
plt.title(f'Clusters Visualization with k = {optimal_k}')
plt.xlabel('tenure (Standardized)')
plt.ylabel('MonthlyCharges (Standardized)')
plt.legend()
plt.grid(True)
plt.show()

